# C 语言数据结构 复习笔记

## 一、绪论

### 1.1 数据结构讨论的范畴

    程序设计：为计算机处理问题编制一组指令集。</br>
    算法：处理问题的策略。</br>
    数据结构：数据结构描述现实世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。

### 1.2 数据结构基本概念

<font color=#00a1d6>

> 数据

    所有能被输入到计算机中，且被计算机处理的符号的集合计算机操作的对象的总称，是计算机处理的信息的某种特定的符号表示形式。

> 数据元素

    数据中的一个“个体”，数据结构中讨论的基本单位。

> 数据项

    数据结构中讨论的最小单位，数据元素是数据项的集合。

> 数据结构

    带结构的数据元素的集合。（线性结构、树形结构、图状结构、集合结构。）

> 数据结构的形式定义

    数据机构是一个二元组
    Data_Structures = (D,S) （D是数据元素的有限集，S是D上关系的有限集）。

> 数据的存储结构

    逻辑结构在存储器中的映像。

> 关系的映像方法（表示(<x,y>)的方法）：

    顺序映像：以存储位置的相邻表示后继关系y的存储位置和x的存储位置之间差一个常量C，C是一个隐含值，整个存储结构中只含数据元素本身的信息。

    链式映像：以附加信息（指针）表示后继关系

>
> 数据类型
    
     数据类型是一个值得集合和定义在此集合上的一组操作的总称。

> 抽象数据类型

    是指一个数学模型以及定义在此数学模型上的一组操作。

>ADT的两个重要特征

    数据抽象、数据封装。

> 抽象数据类型的描述方法

    (D,S,P)三元组表示 （D 是数据对象，S 是 D 上的关系集，P 是对 D 的基本操作集）。
    抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。

</font>

### 1.3 算法和算法的衡量

<font color=#00a1d6>

> 算法

    算法是为了解决某类问题而规定的一个有限长的操作序列。
    一个算法必须满足以下五个重要特性：
    1）有穷性 2）确定性 3）可行性 4）有输入 5）有输出

> 有穷性、确定性、可行性、输入、输出

    对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。

    对于没准情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。

    算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次的实现。

    作为算法加工对象的量值，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入到算法之中。

    是一组与“输入”确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法的功能。

> 算法设计的原则

    正确性
    可读性
    健壮性
    高效率与低存储量需求

> 算法效率的衡量方法和准则

    事后统计法:
        缺点：必须执行程序、其他因素掩盖算法本质

    事前分析估算法

> 和算法执行时间相关的因素

    算法选用的策略
    问题的规模
    编写程序的语言
    编译程序产生的机器代码的质量
    计算机执行指令的速度

> 算法时间复杂度 T(n)=O(f(n))

    算法的执行时间 = ∑ 原操作(i)的执行册数 × 源操作(i)的执行时间
    算法 = 控制结构 + 源操作（固有数据类型的操作）

> 算法存储空间复杂度 S(n)=O(g(n))

    算法的存储量包括：
        输入数据所占控件
        程序本身所占空间
        辅助变量所占空间

</font>

## 二、线性表

    线性结构是一个数据元素的有序（次序）集
    线性结构的基本特征：
        1）集合中必须存在唯一的一个“第一元素”
        2）集合中必须存在唯一的一个“最后元素”
        3）除最后元素在外，均有唯一的后继
        4）除第一元素之外，均有唯一的前驱

### 2.1 线性表的类型定义

<font color=#00a1d6>

> 抽象数据类型线性表的定义

<font color=#fe759b>
ADT List{<br/>
    &emsp;数据对象：<br/>
    &emsp;&emsp;D={a<sub>i</sub> | a<sub>i</sub> $\in$ ElemSet, i=1,2,3,4...,n, n $\geq$ 0}
    &emsp;{n为线性表的表长，n=0时的线性表为空表。}<br/>
    &emsp;数据关系：<br/>
    &emsp;&emsp;R={<a<sub>i-1</sub>,a<sub>i</sub>> | a<sub>i-1</sub>,a<sub>i</sub> $\in$ D, , i=1,2,3,4...,n}
    &emsp;{设线性表为(a<sub>1</sub>，a<sub>2</sub>，....，a<sub>n</sub>)，称i为a在线性表中的位序。}<br/>
    &emsp;基本操作：<br/>
    &emsp;&emsp;结构初始化&emsp;InitList(&L)<br/>
    &emsp;&emsp;销毁结构&emsp;&emsp;DestroyList(&L)<br/>
    &emsp;引用型操作：<br/>
    &emsp;&emsp;为空校验&emsp;&emsp;ListEmpty(L)<br/>
    &emsp;&emsp;获取表长&emsp;&emsp;ListLength(L)<br/>
    &emsp;&emsp;获取前驱&emsp;&emsp;PriorElem(L, cur_e, &pre_e)<br/>
    &emsp;&emsp;获取后继&emsp;&emsp;GetElem(L, i, &e)<br/>
    &emsp;&emsp;获取位置&emsp;&emsp;LocateElem(L, e, compare())<br/>
    &emsp;&emsp;访问元素&emsp;&emsp;ListTraverse(L, visit())<br/>
    &emsp;加工型操作：<br/>
    &emsp;&emsp;清空表&emsp;&emsp;ClearList(&L)<br/>
    &emsp;&emsp;修改元素&emsp;&emsp;PutElem(L, i, &e)<br/>
    &emsp;&emsp;表插入&emsp;&emsp;ListInsert(&L, i, e)<br/>
    &emsp;&emsp;表删除&emsp;&emsp;ListDelete(&L, i, &e)
    <br/>
}

</font>

### 2.2 线性表类型的实现 -- 顺序映像

    用一组地址连续的存储单元，一次存放线性表中的数据元素。
    以“存储位置相邻”表示有序对<a[i-1],a[i]>，即：LOC(a[i])=LOC(a[i-1])+C，C为一个数据元素所占存储量
    所有数据元素的存储位置均取决于第一个数据元素的存储位置，即：LOC(a[i])=LOC(a[1])+(i-1)C，a[1]为基地址

    优点：可以随机存取
    缺点：插入删除都需要移动表内元素

### 2.3 线性表类型的实现 -- 链式映像

#### 2.3.1 单链表

    用一组地址任意的存储单元存放线性表中的数据元素。
    以元素（数据元素的映像） + 指针（指示后继元素存储位置） = 结点（表示数据元素）。
    以“结点的序列”表示线性表，又称作链表。

> 头指针

    指向第一个数据元素的指针，叫做头指针

> 头结点

    为了方便，在第一个元素之前，加一个头结点，其数据元素为空，指针将指向其后继元素。若链表为空，则头结点的指针域为空。

### 2.4 一元多项式的表示

<font color=#00a1d6>



</font>